---
layout: layouts/base.liquid
title: CSS Grid Generator
columns: 12
grid_breakpoint_tablet: 48rem
grid_breakpoint_desktop: 60rem
grid_columns_mobile: 1
grid_column_gap_mobile: var(--column-gap-mobile, 0.75rem)
grid_row_gap_mobile: var(--row-gap-mobile, 0.5lh)
grid_columns_tablet: 2
grid_column_gap_tablet: var(--column-gap-tablet, 1.125rem)
grid_row_gap_tablet: var(--row-gap-tablet, 0.75lh)
grid_columns_desktop: 12
grid_columns_desktop_factors: "2,3,4,6,12"
grid_column_gap_desktop: var(--column-gap-desktop, 1.5rem)
grid_row_gap_desktop: var(--row-gap-desktop, 1lh)
use_prism: true
---

<main>
  <h1>CSS Grid Generator</h1>

  <section class="gs-input">
    <h2>Grid configuration</h2>
    {% include "grid-input.liquid" %}
  </section>

  <section class="gs-output">
    <h2>Generated CSS</h2>
    {% comment %}Populated by js{% endcomment %}
    <a download href target="_blank">Download this file</a>
    <pre class="gs-output"><code class="language-css"></code></pre>
  </section>

  <section class="gs-demo">
    <h2>Grid demo</h2>
    {% comment %}Populated by js{% endcomment %}
    <style class="gs-demo-styles"></style>
    <div class="gs-html"></div>
  </section>
</main>

<script>
  window.pathPrefix = "{{ '/'|url }}";
  {% if process.env.NODE_ENV == "development" %}window.development = true;{% endif %}
</script>
<script src="{{ '/assets/liquid.browser.min.js'|url }}"></script>
<script src="{{ '/assets/standalone.js'|url }}"></script>
<script src="{{ '/assets/postcss.js'|url }}"></script>
<script src="{{ '/assets/prism.js'|url }}" data-manual></script>
<script src="{{ '/assets/urlon.umd.js'|url }}" deferred></script>
<script src="{{ '/assets/qs.js'|url }}" deferred></script>
<script>
  /**
   *
   */
  class FormState extends FormData {
    /**
     *
     */
    constructor(form, submitter, dependentFields = {}, initialState = {}) {
      super();
      this.form = form;
      this.dependentFields = dependentFields;
      this.initialState = initialState;
      this.#init();
      this.form.addEventListener("change", this.#updateData);
    }

    /**
     *
     */
    #init = () => {

      // TODO handle this.initialState here.
      //
      // THIS WILL BE ENCODED...
      //
      // this.initialState has to be something like, e.g.:
      //
      // [
      //   { name: "foo", value: "bar" },
      // ]
      //
      // We're going to assume that (since it's generated by us) that the query
      // parameter this.initialState derives from contains *every* key/value from the
      // form that produced it.
      //
      // For future-proofing (i.e. in case the form adds new keys), we're going
      // to need to "merge" the query-string data with the form data. That's a
      // bit tricky since one is a list of bare objects, and the other is a list
      // of DOM nodes.
      //
      // Do we extract the info from the DOM nodes first? It'd be extra some
      // extra cycles...
      //
      // I guess we can check, in the existing loop, for this.initialState values to
      // override what we _find_ in the form.
      //
      // this.initialState will never be used after this.#init().
      Array.from(this.form.elements).forEach((el) => {
        this.initializing = true;
        this.#updateData(el);
        this.initializing = false;
      });
    };

    /**
     *
     */
    #updateData = (target) => {
      const field = target instanceof Event ? target.target : target;
      const { name, value } = field;

      // Re: dependentFields. These never satisfy the conditions to be able to
      // use this.set(name, value). We'd expect them to be hidden in most cases
      // anyhow.
      //
      // We don't worry about running this.get(field) for the callback arg
      // because we don't do dependentFields computations on init, and after
      // that, the object only gets updated one field at a time (i.e. whatever
      // value 'field' has is the right one, because IT did not change).
      if (name) {
        if (this.dependentFields.hasOwnProperty(name) && !this.initializing) {
          console.log({
            name,
            field,
            fieldValue: this.get(field),
            computed: callback(this.get(field)),
          });
          const [callback, field] = this.dependentFields[name];
          this.set(name, callback(this.get(field)));
        } else {
          this.set(name, value);
        }
      }
    };

    /**
     *
     *
     * @see https://github.com/cerebral/urlon
     */
    serialize = () => urlon.stringify(this.dump());

    /**
     *
     *
     * @see https://github.com/cerebral/urlon
     */
    unserialize = (serialized) => urlon.parse(serialized);

    /**
     *
     */
    dump = () => Object.fromEntries(this);
  }
</script>
<script>
  (async function() {
    /**
     * Performs a factorization of the incoming columns value using its root.
     *
     * @param {number} columns
     *   The number of columns the grid system will use.
     * @param {number[]}
     *   The list of factors sorted ASC.
     */
    function factorizeColumnCount(columns) {
      const factors = [];
      const n = parseInt(columns, 10);

      for (let i = 1; i <= Math.sqrt(n); i++) {
        if (n % i === 0) {
          factors.push(i);

          // Only add n / 1 to factors if it's not a perfect square.
          if (i !== n / i) {
            factors.push(n / i);
          }
        }
      }

      // We don't care that much about 1 as a factor for CSS purposes.
      return factors.sort((a, b) => a - b).slice(1);
    }

    /**
     * Generates CSS for demo, download.
     */
    async function generateCss() {
      try {
        const unformattedCss = await engine.renderFile("grid-css", data);

        css = await prettier.format(unformattedCss, {
          parser: "css",
          plugins: prettierPlugins,
        });
      } catch (error) {
        console.error('Error generating css:', error);
      }
    }

    /**
     * Generates filename and url for css download link.
     *
     * @param {string} css
     *   The generated css.
     */
    function generateDownload(css) {
      const blob = new Blob([css], { type: "text/css" });
      const filename = `gs-${form.columnsdesktop.value}.css`;

      if (downloadUrl) {
        URL.revokeObjectURL(downloadUrl);
      }

      downloadUrl = URL.createObjectURL(blob);
      downloadLink.setAttribute("download", filename);
      downloadLink.setAttribute("href", downloadUrl);
    }

    /**
     * Generates HTML for demo.
     */
    async function generateHtml() {
      try {
        html = await engine.renderFile("grid-html", data);
      } catch (error) {
        console.error('Template rendering error:', error);
      }
    }

    /**
     * Handles form submit.
     *
     * @param {Event} event
     *   The event passed in by the listener.
     */
    async function handleFormControlChange(event) {
      event.preventDefault();
      renderOutput();
    }

    /**
     * Renders output.
     */
    async function renderOutput() {
      data = formState.dump();
      await generateCss();
      await generateHtml();
      output.innerHTML = css;
      demoStyles.textContent = css;
      demo.innerHTML = html;
      generateDownload(css);
      Prism.highlightElement(output);
    }

    const form = document.querySelector(".gs-form");
    const demo = document.querySelector(".gs-demo > .gs-html");
    const demoStyles = document.querySelector(".gs-demo-styles");
    const output = document.querySelector(".gs-output > pre > code");
    const downloadLink = document.querySelector(".gs-output a[download]");
    const engine = new liquidjs.Liquid({
      cache: !window?.development,
      extname: ".liquid.tpl",
      root: `${pathPrefix}assets/templates/`,
    });
    let downloadUrl;
    let data;
    let css;
    let html;
    const formState = new FormState(
      form,
      undefined,
      {
        grid_columns_desktop_factors: [
          factorizeColumnCount,
          "grid_columns_desktop"
        ]
      },
    );

    if (
      !form
      || !demo
      || !demoStyles
      || !output
      || !downloadLink
      || !Prism
    ) {
      return;
    }

    await renderOutput();
    form.addEventListener("change", handleFormControlChange);
  })();
</script>
